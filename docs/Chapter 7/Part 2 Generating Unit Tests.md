## Generating Unit Tests

Unit tests are the bedrock of a stable codebase. They validate the smallest pieces of logic in isolation, ensuring that each function behaves as expected. AI test generation is particularly effective at this level.

Let's return to the `applyCoupon` function from the previous chapter. The implementation was generated by an AI based on our spec. Now, we want to validate that the implementation is correct. We can issue a new prompt to our AI agent.

**Prompt to the AI Agent:**

> "Generate a complete Jest test suite for the `applyCoupon` function in `src/logic/checkout.ts`. The suite must cover all scenarios described in the `checkout.spec.md` file, including valid codes of each type (`PERCENT`, `FIXED`, `FREE_SHIPPING`), invalid codes, and edge cases like the total not dropping below zero."

The AI agent will then read the function's code and the original specification to generate a comprehensive test file.

**AI-Generated `checkout.test.ts`:**

```typescript
import { applyCoupon } from './checkout';

// Mock the getCouponByCode function
jest.mock('./checkout', () => ({
    ...jest.requireActual('./checkout'),
    getCouponByCode: jest.fn(),
}));
const mockedGetCouponByCode = getCouponByCode as jest.Mock;

describe('applyCoupon', () => {
    const baseCart = {
        items: [{ id: 'item1', price: 100, quantity: 1 }],
        subtotal: 100,
        shippingCost: 10,
        discount: 0,
        total: 110,
    };

    beforeEach(() => {
        mockedGetCouponByCode.mockReset();
    });

    it('should apply a valid PERCENT coupon', async () => {
        mockedGetCouponByCode.mockResolvedValue({ code: 'SAVE10', type: 'PERCENT', value: 10, isExpired: false });
        const newCart = await applyCoupon(baseCart, 'SAVE10');
        expect(newCart.discount).toBe(10);
        expect(newCart.total).toBe(100); // 100 (subtotal) - 10 (discount) + 10 (shipping)
    });

    it('should apply a valid FIXED coupon', async () => {
        mockedGetCouponByCode.mockResolvedValue({ code: '5OFF', type: 'FIXED', value: 5, isExpired: false });
        const newCart = await applyCoupon(baseCart, '5OFF');
        expect(newCart.discount).toBe(5);
        expect(newCart.total).toBe(105); // 100 - 5 + 10
    });

    it('should apply FREE_SHIPPING for subtotal over $50', async () => {
        mockedGetCouponByCode.mockResolvedValue({ code: 'FREESHIP', type: 'FREE_SHIPPING', value: 0, isExpired: false });
        const newCart = await applyCoupon(baseCart, 'FREESHIP');
        expect(newCart.shippingCost).toBe(0);
        expect(newCart.total).toBe(100); // 100 - 0 + 0
    });

    it('should NOT apply FREE_SHIPPING for subtotal under $50', async () => {
        const lowValueCart = { ...baseCart, subtotal: 40, total: 50 };
        mockedGetCouponByCode.mockResolvedValue({ code: 'FREESHIP', type: 'FREE_SHIPPING', value: 0, isExpired: false });
        const newCart = await applyCoupon(lowValueCart, 'FREESHIP');
        expect(newCart.shippingCost).toBe(10); // Remains unchanged
        expect(newCart.total).toBe(50);
    });

    it('should throw an error for an invalid coupon code', async () => {
        mockedGetCouponByCode.mockResolvedValue(null);
        await expect(applyCoupon(baseCart, 'INVALID')).rejects.toThrow('Invalid or expired coupon code.');
    });

    it('should not allow the total to drop below zero', async () => {
        mockedGetCouponByCode.mockResolvedValue({ code: 'MASSIVE_DISCOUNT', type: 'FIXED', value: 200, isExpired: false });
        const newCart = await applyCoupon(baseCart, 'MASSIVE_DISCOUNT');
        expect(newCart.discount).toBe(100); // Discount is capped at subtotal
        expect(newCart.total).toBe(10); // 100 (subtotal) - 100 (capped discount) + 10 (shipping)
    });
});
```
This generated suite is not just a skeleton; it's a thorough validation of our business logic. It correctly mocks the external dependency (`getCouponByCode`), tests each success case, and verifies the failure and edge case conditions. The developer's work is reduced to a quick review to confirm that the tests accurately reflect the intent of the spec.